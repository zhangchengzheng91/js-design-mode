/*
* 技巧型设计模式
* 执行控制 --- 节流模式（Throttler）:对重复的业务逻辑进行节流控制，执行最后一次操作并
* 取消其他操作，以提高性能。
*
* 节流很简单，你可以简单理解为屏蔽重复的事情（业务逻辑）只执行最后一次。
* */

// 节流器
/*
* 构造节流器的思路：首先节流器应该能做两件事，第一件事情就是清除将要执行的函数，此时
* 要对节流器传递两个参数（是否清除，执行函数），如果第一个参数为 true，则表示清除将
* 要执行的函数。同时会判断第二个参数（执行函数）有没有计时器句柄，有则清除计时器。节
* 流器做的第二件事情就是延迟执行函数。此时要传递两个参数（执行函数，相关参数）。在节
* 流器内部首先要为执行函数绑定一个计时器句柄，来保存该执行函数的计数器，对于第二个参
* 数 --- 相关参数来说，大致包括3个部分，执行函数时的作用域、执行函数的参数、执行函数
* 延迟执行时间。
* */
var throttle = function() {
  // 获取第一个参数
  var isClear = arguments[0]
  var fn
  // 如果第一个参数是 boolean 类型，那么第一个参数则表示是否清楚计时器
  if (typeof isClear === 'boolean') {
    // 第二个参数则为函数
    fn = arguments[1]
    // 函数的计时器句柄存在，则清楚计时器
    fn._throttleID && clearTimeout(fn._throttleID)
  // 通过计时器延后函数的执行
  } else {
    // 第一个参数为函数
    fn = isClear
    // 第二个参数为函数执行时的参数
    var param = arguments[1]
    // 对执行时的参数适配默认值，这里我们用到以前学过的extend 方法
    var p = {
      context: null, // 执行函数执行时的作用域
      args: [],  // 执行函数执行时的相关参数
      time: 300, // 执行函数延迟执行的时间
      param,
    }
    // 清除执行函数计时器句柄
    arguments.callee(true, fn)
    // 为函数绑定计时器句柄，延迟执行函数
    fn._throttleID = setTimeout(function() {
      // 执行函数
      fn.apply(p.context, p.args)
    }, p.time)
  }
}
